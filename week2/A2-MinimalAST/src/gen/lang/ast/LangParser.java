package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAREN = 1;
		static public final short ID = 2;
		static public final short READ = 3;
		static public final short NUMERAL = 4;
		static public final short RPAREN = 5;
		static public final short LT = 6;
		static public final short GT = 7;
		static public final short GTE = 8;
		static public final short LTE = 9;
		static public final short EQ = 10;
		static public final short NEQ = 11;
		static public final short SEMICOLON = 12;
		static public final short COMMA = 13;
		static public final short INT = 14;
		static public final short PLUS = 15;
		static public final short MINUS = 16;
		static public final short IF = 17;
		static public final short WHILE = 18;
		static public final short PRINT = 19;
		static public final short RETURN = 20;
		static public final short RBRACE = 21;
		static public final short MUL = 22;
		static public final short DIV = 23;
		static public final short MOD = 24;
		static public final short LBRACE = 25;
		static public final short EQUALS = 26;
		static public final short ELSE = 27;

		static public final String[] NAMES = {
			"EOF",
			"LPAREN",
			"ID",
			"READ",
			"NUMERAL",
			"RPAREN",
			"LT",
			"GT",
			"GTE",
			"LTE",
			"EQ",
			"NEQ",
			"SEMICOLON",
			"COMMA",
			"INT",
			"PLUS",
			"MINUS",
			"IF",
			"WHILE",
			"PRINT",
			"RETURN",
			"RBRACE",
			"MUL",
			"DIV",
			"MOD",
			"LBRACE",
			"EQUALS",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9p5LrjiLKKKNMTEBnJRNg10RKLQIrzuQIiYAeflgwYeF1GiGjLQy97eXu$43nD3Z7$#wO#" +
		"F3oCcnlZZXuacXgY97txoL4JafQ922mLR47auhZEFSsUcz$QsOiBTsRDdhxrcPkzpvfmp5u" +
		"XVHHDgqOXvSbSeY5Mx88cY7TCD$dCeoAZMyYx5nMX0XzmN2YQejWwpSIMkaDyP$40eA5Ujd" +
		"M#kcMzlACYgrlAkCVYFeM2IQYrleS6tXu8MrLhUzGRV7mhcgzRKWJAJtvvGS9LgBQ$Fu3#4" +
		"WfjLQtct6NndABXBjJg$6ZnkyEz3mHBLslbM6FodKB1KjPRNO$3TeM2zQYVYCKpcRe71$Ts" +
		"o0rFKRh6pjPazj0vTyb0eM8KPc2N$20LG#E#X6FotK0n#C1I3$ngAmNy9nU37jQGxO15Mur" +
		"5Sn8gFIwbQowZ3xQfAOAKyYp9vM0lzAhaLVRWVYt4Jrg22w5QEF9pAIItfKp2iXPoJSfiyQ" +
		"kEKORcDw70g9xIa8uUqa7D2df6dR9moX5xwGod3PglhgfT$Qb7P$YN$JhEzZoXz6oV3ZhHt" +
		"DLzt5PAV7VbWu7VBOrhIR0UrCDjZ2T76AOFA7qnbG4iwibyBEGEAEP1Al$BxKqO#EyWjc8Q" +
		"PoE5gN8lhMESM9xly$Rqy7NC3uqzGMo7Gh6fXHN9pEiRoBbDZdPM2odtFtqdt1lu3WV#Gvr" +
		"Tw5LJZHi$tQz1tPmvkzJXk$qxSKsHyijBoKMB5SthOYJtYHkGHTHNMEl6fJlyIft#Bqx$3w" +
		"T$jz9Sv#szyjbDzsSx9q$8V5FoPMCIlrYpK8uC9VC#LOnAV#WfMMyMzC1bJJBI1Tx#6R$lQ" +
		"0ZmnHbwaU17vCRyScQAypF#yRjqOUMDTrwyZMsA#qZn$lieIF9jVIubwxNnrvxrkY#BDuTD" +
		"MYOXV0ytpMHdkR7UsAiCIn8jbE0Bdt1SIjxddTq0ZdwKcHhDyMYIVuse#wTFvlJHCOZCvMz" +
		"RniyhFCxDgzX4ZGsj6LlxdaHb$96NaI5lN#4SMM5DABxlGlu0Z5UhVO$zQklVNhjBAU3CrX" +
		"pQqgnauEphICVurT5Voi$2zO2UDqm#VCDSlM4F06UlusQF6Hil9ZNaHTHNcUl7pwHVP4oMj" +
		"daD$xGh#k3CI0PxSe6bl0D6RGFmS#mtK1VJVfUsYTWDY7Vst6N#UzdrYQsXvIeu#OvyyyIt" +
		"xNxB$2MqxxJVKQTJalDQMf47EPiPQgGkfEuaj8ZQLTYcrJsK5dYI09AMNo645efFs0rgUqy" +
		"GIzfDyNcT$F#rxr4#fN1jlKJ#YxgRoT1al9tSPxKhQjRIhQP#YlaZzcXgJHnltSAu3x6yYj" +
		"frQGwoN6Fz$HCbSE#Ylfv#SM7cU5AyGvsasEaN$B6DF4pl7FkiHl8Q2Py7eDMeZ#xnUOWOr" +
		"Hnxh5FE9Vq4knuh5n9BwM7kqXzY7j7kf7TJJr3EClw3lZUZbfJcqmLmOSxy6ylteMN8#TkF" +
		"vM5nj#vnZs8pTPFo3XbDhy78ptowpxil#NA8dyBzoyfddhBcYK2uEjylORcEVAP9xVG6iEV" +
		"1pJZx9zT$dn9oSn3lK8uw$aJeSp2MAvFjv4LpLpNTbn1sUgE1P0TI89yXodXeYQinJXE3x8" +
		"rPl6wrbr8b6AwY2RmnG8yLhecqYriX#OOtuReYDHdnQOqUJKsrCZVW6S3L6ybIsir$FzNEq" +
		"EMAjj9t$0fxoOTi=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	public LangParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = programlist.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
			}
			case 1: // programlist = function.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Function a = (Function) _symbol_a.value;
					 return new List().add(a);
			}
			case 2: // programlist = programlist.a function.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Function b = (Function) _symbol_b.value;
					 return a.add(b);
			}
			case 5: // function = INT ID.id LPAREN opt$functionarguments.arg RPAREN LBRACE statementlist.sl RBRACE
			{
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arg = _symbols[offset + 4];
					final List arg = (List) _symbol_arg.value;
					final Symbol _symbol_sl = _symbols[offset + 7];
					final List sl = (List) _symbol_sl.value;
					 return new Function(id, arg, sl);
			}
			case 6: // functionarguments = functionargument.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ASTNode a = (ASTNode) _symbol_a.value;
					 return new List().add(a);
			}
			case 7: // functionarguments = functionarguments.a COMMA functionargument.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final ASTNode b = (ASTNode) _symbol_b.value;
					 return a.add(b);
			}
			case 8: // functionargument = INT ID.a
			{
					final Symbol a = _symbols[offset + 2];
					 return new Var(a);
			}
			case 9: // statement = INT ID.a SEMICOLON
			{
					final Symbol a = _symbols[offset + 2];
					 return new IdDecl(a);
			}
			case 10: // statement = PRINT LPAREN expr.a RPAREN SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					 return new Print(a);
			}
			case 11: // statement = INT ID.a EQUALS expr.b SEMICOLON
			{
					final Symbol a = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expr b = (Expr) _symbol_b.value;
					 return new IdDeclAndUse(a,b);
			}
			case 12: // statement = ID.a EQUALS expr.b SEMICOLON
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new IdUse(a, b);
			}
			case 13: // statement = WHILE LPAREN expr.a RPAREN LBRACE statementlist.b RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new While(a,b);
			}
			case 14: // statement = IF LPAREN expr.a RPAREN LBRACE statementlist.b RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new If(a,b);
			}
			case 15: // statement = IF LPAREN expr.a RPAREN LBRACE statementlist.b RBRACE ELSE LBRACE statementlist.c RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 10];
					final List c = (List) _symbol_c.value;
					 return new IfElse(a,b,c);
			}
			case 16: // statement = expr.a SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExpressionStatement(a);
			}
			case 19: // statement = RETURN opt$expr.a SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Return(a);
			}
			case 20: // statementlist = statement.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Statement a = (Statement) _symbol_a.value;
					 return new List().add(a);
			}
			case 21: // statementlist = statementlist.a statement.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Statement b = (Statement) _symbol_b.value;
					 return a.add(b);
			}
			case 22: // expr = expr.a LT arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LT(a,b);
			}
			case 23: // expr = expr.a GT arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GT(a,b);
			}
			case 24: // expr = expr.a GTE arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GTE(a,b);
			}
			case 25: // expr = expr.a LTE arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LTE(a,b);
			}
			case 26: // expr = expr.a EQ arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new EQ(a,b);
			}
			case 27: // expr = expr.a NEQ arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NEQ(a,b);
			}
			case 28: // expr = arexpr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 29: // arexpr = arexpr.a PLUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Plus(a,b);
			}
			case 30: // arexpr = arexpr.a MINUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Minus(a,b);
			}
			case 31: // arexpr = term.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 32: // term = term.a MUL factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
			}
			case 33: // term = term.a DIV factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
			}
			case 34: // term = term.a MOD factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
			}
			case 35: // term = factor.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 36: // factor = LPAREN expr.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 37: // factor = op.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 38: // op = ID.a
			{
					final Symbol a = _symbols[offset + 1];
					 return new Var(a);
			}
			case 39: // op = NUMERAL.a
			{
					final Symbol a = _symbols[offset + 1];
					 return new Numeral(a);
			}
			case 40: // op = functioncall.a
			{
					final Symbol a = _symbols[offset + 1];
					 return a;
			}
			case 41: // op = READ LPAREN RPAREN
			{
					 return new Read();
			}
			case 44: // functioncall = ID.a LPAREN opt$argumentcalls.args RPAREN
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_args = _symbols[offset + 3];
					final List args = (List) _symbol_args.value;
					 return new FuncCall(a, args);
			}
			case 45: // argumentcalls = argumentcall.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
			}
			case 46: // argumentcalls = argumentcalls.a COMMA argumentcall.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
			}
			case 47: // argumentcall = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 3: // opt$functionarguments = 
			case 17: // opt$expr = 
			case 42: // opt$argumentcalls = 
			{
				return new Symbol(null);
			}
			case 4: // opt$functionarguments = functionarguments
			case 18: // opt$expr = expr
			case 43: // opt$argumentcalls = argumentcalls
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
