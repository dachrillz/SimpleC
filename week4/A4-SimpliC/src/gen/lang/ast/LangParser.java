package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAREN = 1;
		static public final short ID = 2;
		static public final short RPAREN = 3;
		static public final short NUMERAL = 4;
		static public final short COMMA = 5;
		static public final short LT = 6;
		static public final short GT = 7;
		static public final short GTE = 8;
		static public final short LTE = 9;
		static public final short EQ = 10;
		static public final short NEQ = 11;
		static public final short SEMICOLON = 12;
		static public final short INT = 13;
		static public final short PLUS = 14;
		static public final short MINUS = 15;
		static public final short MUL = 16;
		static public final short DIV = 17;
		static public final short MOD = 18;
		static public final short IF = 19;
		static public final short WHILE = 20;
		static public final short RETURN = 21;
		static public final short RBRACE = 22;
		static public final short LBRACE = 23;
		static public final short EQUALS = 24;
		static public final short ELSE = 25;

		static public final String[] NAMES = {
			"EOF",
			"LPAREN",
			"ID",
			"RPAREN",
			"NUMERAL",
			"COMMA",
			"LT",
			"GT",
			"GTE",
			"LTE",
			"EQ",
			"NEQ",
			"SEMICOLON",
			"INT",
			"PLUS",
			"MINUS",
			"MUL",
			"DIV",
			"MOD",
			"IF",
			"WHILE",
			"RETURN",
			"RBRACE",
			"LBRACE",
			"EQUALS",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ozbbbiLLKKXlzpRYc3N10P2WMfXHOwC2EA8g2YEE5OiO8QIKmmCIOccgZeWoOQ4XwD3pw" +
		"WyO7ue0dwu8CFFc1YZ8ac6a660cKgWmYTQ8iWmlOx##pRk$SfROCGxyf$$xNMl$O#wvozpo" +
		"35fyqUbPZzofdzeMcfvy$G94rJjJbcze30DDF#JzHDccUEgC4S2Kr3lEYebfkZeQdK$gVZ3" +
		"sk4EHoQXdjHCrqrXwRHNhIFRlQ5fXLUj9VvzuQcbLwqI$URNQ4neXYrw27J4Xfwyf$sVqWF" +
		"cqCPs#tv1zLe3eQcfxne9#UtCpGzxKK7EDg1qBJMYquR0mAJD45JpIbMvbHeJldJN0I1EUK" +
		"aoidGdFA7#GS4vfGJA2T2SyfnoHmFJMiIHSkq8DbTcglRz8WQDShybPYU1CdlElPVMb56fk" +
		"1Nf5Lf3V$XBCzeb8Pfg5OhtpiYKMQPCzW5SqRbcgubgh9SeweqOoxWNR8r61DVhrLSkLRJo" +
		"Z5QpINTfxlrc4PgZ3cBjO8UquFMazHOEykePAOUPZhhh2Uri1EYIXl9R5Sz6ASfcgs5MgHR" +
		"JRVf9jzjkamNt6Mxl9qPasmdrWMwdNKvwpGTfWEzmzLWUErO1sWpRKHjIOsrTjTd6xEsEsj" +
		"BJGtqDZ$jpPsnt$aDVgSQ6sYJTOTTCx$2r#yCbBi2xHxTE#3O1$HW7ztt7msg7m#q9pnjlE" +
		"VVwFbpFFzcpx$5ynUR9gvY4y$C9ZrhLqNieTXcV#kD2vnKPdFNcclD3jMP7UPtSzxYdFaxW" +
		"I8wpg4FKIdtmJ0DrmZkf96AkJD6iw$7i8xbhDSKha6EvrUsBlBgSjn5MNrwe0yslgoFNXde" +
		"yI3pHrSvVz$nPO5UUSLwFCZrgRwYynkiVsLrOwn#cIFtAl$J63ZRUyugXTqrLHMy7VFiHx4" +
		"ECNTJ2Uyfepgl8k$vOxbpnsk2hPcKcQNQxkeQZZWZeoGpIoMMPpgkX$FMo#EfE3CzJaeL$A" +
		"J6AUpZGdL1AoXvee9Mo1KuxCH5rEVe9BmsXLazfgfamDbx#mJ5C$WlVUQztj9Ss7cuYg6Mi" +
		"#lXLroxiNtrWMRhNxiQFxBhDOtrgkgzfhLsby$AhXgOUBcLlAQSmuPWMPQUUzU#1kbUukig" +
		"Yk0HO3d#4l0I$ZnuChW8tWUyEQCFoA#6tmERmTjIF0x#5Bo3rW9$RkyInP$0l5$Ypm1V0N6" +
		"IvxiY$WfU27yDhm0DTkMa5y1hO3rpR4TlnkSuyJVW0BbjyBVaw4SVuXDh2s2U#7jq#ez$XC" +
		"lWds7UdT5yTBJuCBm3$WYkW7y52z1$8du5Fz6INjQH#mNUIBmRDE1l8FS6l0dUGsuDV0pU1" +
		"rx4Jxw2leJvoj8Nv8x0Fy3Kw3loR#7pvHfjIgzvl87JFUYkVpxbQAMBvxfuPdAz4z$bbnRz" +
		"w7pHZzUwtEA4cVUSomzrlCxfonnlAOpD0gtHyp$sZh7UotTw#PSTl#hupVxcTdfP9gvsv$Q" +
		"ybrlaSgyxtfWPiwhllDhiUAlZRHaz#SsnTs2jHSpTMMg$Qcg8QxWdgibLmZCialT2YUC4Gq" +
		"5ijJhgw$1vslI3YDsLSuXu9kGyH3mfSY3YUL74T51klxGYdY8bzakg7h$UFlaZpVuNqJZh0" +
		"G==");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	public LangParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = programlist.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
			}
			case 1: // programlist = function.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Function a = (Function) _symbol_a.value;
					 return new List().add(a);
			}
			case 2: // programlist = programlist.a function.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Function b = (Function) _symbol_b.value;
					 return a.add(b);
			}
			case 3: // function = type.t iddecl.id LPAREN functionarguments.arg RPAREN block.sl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_arg = _symbols[offset + 4];
					final List arg = (List) _symbol_arg.value;
					final Symbol _symbol_sl = _symbols[offset + 6];
					final Block sl = (Block) _symbol_sl.value;
					 return new Function(t, id, arg, sl);
			}
			case 4: // function = type.t iddecl.id LPAREN RPAREN block.sl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_sl = _symbols[offset + 5];
					final Block sl = (Block) _symbol_sl.value;
					 return new Function(t, id, new List(), sl);
			}
			case 5: // functionarguments = functionargument.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return new List().add(a);
			}
			case 6: // functionarguments = functionarguments.a COMMA functionargument.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return a.add(b);
			}
			case 7: // functionargument = INT iddecl.a
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return a;
			}
			case 8: // block = LBRACE statementlist.a RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
			}
			case 9: // statement = type.t iddecl.a SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return new Decl(t, a, new Opt());
			}
			case 10: // statement = type.t iddecl.a EQUALS expr.b SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expr b = (Expr) _symbol_b.value;
					 return new Decl(t, a,new Opt(b));
			}
			case 11: // statement = iduse.a EQUALS expr.b SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Assignment(a, b);
			}
			case 12: // statement = WHILE LPAREN expr.a RPAREN block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new While(a,b);
			}
			case 13: // statement = IF LPAREN expr.a RPAREN block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new If(a,b);
			}
			case 14: // statement = IF LPAREN expr.a RPAREN block.b ELSE block.c
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Block c = (Block) _symbol_c.value;
					 return new IfElse(a,b,c);
			}
			case 15: // statement = expr.a SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExpressionStatement(a);
			}
			case 16: // statement = RETURN expr.a SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Return(a);
			}
			case 17: // statementlist = statement.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Statement a = (Statement) _symbol_a.value;
					 return new List().add(a);
			}
			case 18: // statementlist = statementlist.a statement.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Statement b = (Statement) _symbol_b.value;
					 return a.add(b);
			}
			case 19: // expr = expr.a LT arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LT(a,b);
			}
			case 20: // expr = expr.a GT arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GT(a,b);
			}
			case 21: // expr = expr.a GTE arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GTE(a,b);
			}
			case 22: // expr = expr.a LTE arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LTE(a,b);
			}
			case 23: // expr = expr.a EQ arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new EQ(a,b);
			}
			case 24: // expr = expr.a NEQ arexpr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NEQ(a,b);
			}
			case 25: // expr = arexpr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 26: // arexpr = arexpr.a PLUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Plus(a,b);
			}
			case 27: // arexpr = arexpr.a MINUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Minus(a,b);
			}
			case 28: // arexpr = term.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 29: // term = term.a MUL factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
			}
			case 30: // term = term.a DIV factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
			}
			case 31: // term = term.a MOD factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
			}
			case 32: // term = factor.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 33: // factor = LPAREN expr.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 34: // factor = op.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 35: // op = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
			}
			case 36: // op = NUMERAL.a
			{
					final Symbol a = _symbols[offset + 1];
					 return new Numeral(a);
			}
			case 37: // op = functioncall.a
			{
					final Symbol a = _symbols[offset + 1];
					 return a;
			}
			case 38: // iddecl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 	return new IdDecl(id);
			}
			case 39: // iduse = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 	return new IdUse(id);
			}
			case 40: // type = INT.a
			{
					final Symbol a = _symbols[offset + 1];
					 return new IntType();
			}
			case 41: // functioncall = iduse.a LPAREN argumentcalls.args RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final List args = (List) _symbol_args.value;
					 return new FuncCall(a, args);
			}
			case 42: // functioncall = iduse.a LPAREN RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					 return new FuncCall(a, new List());
			}
			case 43: // argumentcalls = argumentcall.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
			}
			case 44: // argumentcalls = argumentcalls.a COMMA argumentcall.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
			}
			case 45: // argumentcall = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
